# Implementation Plan: 03 - Minimal Viable Supergraph

**Goal:** Achieve end-to-end federation by assembling the stateless `subgraph-blogs` and the stateful `subgraph-dgraph-static` into a single, running supergraph. This phase proves the core architectural pattern.

This plan is designed to be executed sequentially. It assumes you have cloned all necessary repositories and are executing the commands from within the correct repository's root directory.

## Task Checklist

- [ ] **Phase 1: Minimal Viable Federation**
    - [ ] [Task 1.3: Create `federated-graph-core` Content](#task-13-create-federated-graph-core-content)
    - [ ] [Task 1.4: Create and Configure `supergraph-cncf`](#task-14-create-and-configure-supergraph-cncf)
- [ ] **Phase 2: Integrate Stateful Backend**
    - [ ] [Task 2.2: Integrate `subgraph-dgraph-static` into `supergraph-cncf`](#task-22-integrate-subgraph-dgraph-static-into-supergraph-cncf)

---

### Phase 1: Minimal Viable Federation

#### Task 1.3: Create `federated-graph-core` Content

1.  From within the `federated-graph-core` repository, create the `compose.yaml` for the Hive stack:

        ```yaml
        # Example: compose.yaml for Hive stack
        version: '3.8'
        services:
            postgres:
                image: postgres:13
                environment:
                    POSTGRES_PASSWORD: example
                ports:
                    - "5432:5432"
            redis:
                image: redis:6
                ports:
                    - "6379:6379"
            hive:
                image: ghcr.io/kamilkisiela/graphql-hive:latest
                depends_on:
                    - postgres
                    - redis
                environment:
                    HIVE_DATABASE_URL: postgres://postgres:example@postgres:5432/hive
                    HIVE_REDIS_URL: redis://redis:6379
                ports:
                    - "4000:4000"
        networks:
            default:
                name: graphtastic_net
                external: true
        ```

#### Task 1.4: Create and Configure `supergraph-cncf`

1.  From within the `supergraph-cncf` repository, create a root `Makefile`:

        ```makefile
        .PHONY: up down supergraph

        up:
        	docker-compose up -d

        down:
        	docker-compose down

        supergraph:
        	npx @graphql-mesh/compose-cli -c mesh.config.js -o supergraph.graphql
        ```

2.  Update `graphtastic.deps.yml` to declare the initial set of dependencies. Use local relative paths for components created so far.

        ```yaml
        dependencies:
            - name: subgraph-blogs
                path: ../subgraph-blogs
                version: main
        ```

3.  Create `.env` to provide centralized configuration:

        ```env
        SHARED_NETWORK_NAME=graphtastic_net
        ```

4.  Create `mesh.config.js` to define how the supergraph is composed:

        ```js
        module.exports = {
            sources: [
                {
                    name: 'blogs',
                    handler: {
                        graphql: {
                            endpoint: 'http://subgraph-blogs:4000/graphql',
                        },
                    },
                },
            ],
            additionalTypeDefs: [],
            additionalResolvers: [],
        };
        ```

5.  Create a placeholder `supergraph.graphql` file. The `make supergraph` command will overwrite this.

        ```graphql
        # This file is auto-generated by Mesh Compose CLI
        ```

### Phase 2: Integrate Stateful Backend

#### Task 2.2: Integrate `subgraph-dgraph-static` into `supergraph-cncf`

1.  From within the `supergraph-cncf` repository, update `graphtastic.deps.yml` to include the new Dgraph Spoke:

        ```yaml
        dependencies:
            - name: subgraph-blogs
                path: ../subgraph-blogs
                version: main
            - name: subgraph-dgraph-static
                path: ../subgraph-dgraph-static
                version: main
        ```

2.  Update `mesh.config.js` to add the Dgraph subgraph as a source. Note the use of the `alpha` service name and its internal port `8080`.

        ```js
        module.exports = {
            sources: [
                {
                    name: 'blogs',
                    handler: {
                        graphql: {
                            endpoint: 'http://subgraph-blogs:4000/graphql',
                        },
                    },
                },
                {
                    name: 'characters',
                    handler: {
                        graphql: {
                            endpoint: 'http://alpha:8080/graphql',
                        },
                    },
                },
            ],
            additionalTypeDefs: [],
            additionalResolvers: [],
        };
        ```

3.  To demonstrate a federated join, we will extend the `Blog` type to have a favorite character.
        *   Navigate to your local clone of `subgraph-blogs`.
        *   You do not need to push these changes to a remote repository for local testing.

4.  **Execute and Verify:**
        *   From the `supergraph-cncf` repository root:
        *   The query should succeed, demonstrating that the gateway was able to fetch the `blog` and its `favoriteCharacterId` from the blogs subgraph, and then use that `id` to fetch the character's `name` and `species` from the Dgraph subgraph. This completes the minimal viable supergraph.
